const config = require('../config/index');
const axios = require('axios');
const notice = require('./notice');
class blockIoExplorer{
  constructor (apikey) {
    this.api = axios;
    this.api.defaults.baseURL = config.blockIoURL.baseURL;
    this.api.defaults.headers.common['Content-Type'] = "application/json";
    this.api.create();
    console.log("init api", this.api.defaults.baseURL)
    this.apikey = apikey
  }

  /**
   * Returns a newly generated address, and its unique(!) label generated by Block.io. You can optionally specify a custom label.
   * @param label you can support label mark this address
   * @param type address type witness_v0
   * @returns {Promise.<void>}
   */
  async getNewAddress(label, type){
    label = label ? label : "";
    type = type ? type : "witness_v0";
    try {
      var response = await this.api.get("/get_new_address/?api_key"+ this.apikey+ "&label="+label + "&address_type="+ type)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Returns the balance of your entire Bitcoin, Litecoin, or Dogecoin account (i.e., the sum of balances of all addresses/users within it) as numbers to 8 decimal points, as strings.
   * @returns {Promise.<void>}
   */
  async getBalance(){
    try {
      var response = await this.api.get("/get_balance/?api_key"+ this.apikey)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Returns the (unarchived) addresses, their labels, user ids, and balances on your account. Upto 2500 addresses per page. Page parameter is optional.
   * @param page default 2500
   * @returns {Promise.<void>}
   */
  async getMyAddress(page){
    page = page ? page : 2500;
    try {
      var response = await this.api.get("/get_my_addresses/?api_key"+ this.apikey+"&page="+page)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Returns the balance of the specified addresses, or labels. Upto 2500 addresses/labels can be specified per request.
   * @param addressesOrLabels support mutiple
   * @param type address|labels
   * @returns {Promise.<void>}
   */
  async getAddressBalance(addressesOrLabels, type){
    try {
      var response = await this.api.get("/get_address_balance/?api_key"+ this.apikey+"&"+ type +"="+ addressesOrLabels)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Returns the address specified by a label.
   * @param label
   * @returns {Promise.<void>}
   */
  async getAddressByLabel(label){
    try {
      var response = await this.api.get("/get_address_by_label/?api_key"+ this.apikey+"&label="+ label)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Returns various data for the last 25 transactions spent or received. You can optionally specify a before_tx parameter to get earlier transactions.
   * @param type  sent|received
   * @param beforetx  TXID
   * @param addresses mutiple address `,` split
   * @param userIds mutiple userids `,` split
   * @param labels mutiple labels `,` split
   * @returns {Promise.<void>}
   */
  async getTransactions(type, beforetx=null, addresses=null, userIds=null, labels=null){
    try {
      var response = await this.api.get("/get_transactions/?api_key"+ this.apikey+"&type="+ type+
        (beforetx ? "&before_tx="+beforetx :
          addresses ? "&addresses="+addresses :
            userIds ? "&user_ids="+ userIds :
              labels ? "&labels="+ labels : '')
      )
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   *  Returns the raw data, including transaction hex, for a given transaction ID.
   * @param hash TXID
   * @returns {Promise.<void>}
   */
  async getRawTransaction(hash){
    try {
      var response = await this.api.get("/get_raw_transaction/?api_key"+ this.apikey+"&txid="+ hash)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Returns whether a single specified address is valid for the network, or not.
   * @param addresses
   * @returns {Promise.<void>}
   */
  async isValidAddress(addresses){
    try {
      var response = await this.api.get("/is_valid_address/?api_key"+ this.apikey+"&address="+ addresses)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Returns the prices from the largest exchanges for Bitcoin, Dogecoin, or Litecoin, specified by the API Key. Specifying the base currency is optional.
   * @param currency
   * @returns {Promise.<void>}
   */
  async getCurrentPrice(currency){
    try {
      var response = await this.api.get("/get_current_price/?api_key"+ this.apikey+"&price_base="+ currency)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }

  /**
   * Estimates the Network Fee you will need to pay when you make a withdrawal request. The Network Fee is required by the Bitcoin/Dogecoin/etc. networks, not Block.io.
   * @param amounts support mutiple  amounts `,` split
   * @param to_addresses support mutiple address `,` split
   * @returns {Promise.<void>}
   */
  async getNetworkFeeEstimate(amounts, to_addresses){
    try {
      var response = await this.api.get("/get_network_fee_estimate/?api_key"+ this.apikey+"&amounts="+ amounts +'&to_addresses='+to_addresses)
    } catch (e) {
      throw notice.createErrorString('getBlock', e)
    }
    return response.data;
  }
}

module.exports = blockIoExplorer;